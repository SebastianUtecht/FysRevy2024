#!/usr/bin/env node
// # Global Setup --------------------------------------------------------------

// Required packages
var http = require("http")
,   { Readable } = require("node:stream")
,   args = require("minimist")(process.argv.slice(2))
,   path = require("path")
,   fs = require("fs")
,   fsp = require("fs/promises")
,   srt2vtt = require("srt2vtt")
,   ass2vtt = require("ass-to-vtt")
,   parser = require("node-html-parser")
;

// Global variables
var connections = []
,   lastMessageId = 0
,   history = []
;

var contentTypesByExtension = {
   '.html': "text/html"
  ,'.htm':  "text/html"
  ,'.css':  "text/css"
  ,'.js':   "text/javascript"
  ,'.vtt':  "text/vtt"
  ,'.svg':  "image/svg+xml"
  ,'.jpeg': "image/jpeg"
  ,'.jpg':  "image/jpeg"
  ,'.png':  "image/png"
  ,'.gif':  "image/gif"
  ,'.webp': "image/webp"
  ,'.wav':  "audio/x-wav"
  ,'.mp3':  "audio/mp3"
  ,'.mp4':  "video/mp4"
  ,'.m4v':  "video/mp4"
  , 'woff': "font/woff"
  , 'woff2':"font/woff2"
  , 'otf':  "font/otf"
  , 'ttf':  "font/truetype"
};

// Accept alternate port number (as first (numeric) argument,
// or "--port=" argument).
var port = 80;                  // Default port
if (args.port) {
  port = parseInt(args.port);
} else {
  for (const a of args._) {
    if (!isNaN(parseInt(a))) {
      port = parseInt(a);
      break;
    }
  }
}


// # HTTP server logic ---------------------------------------------------------

const altExts = [".remote", ".left", ".right", ".mid"]
function fileNameWithRealExtension( url ){
  if (altExts.includes(path.extname(url)))
    return "." + path.dirname(url) + "/"
      + path.basename(url, path.extname(url)) + ".html";
  else {
    return "." + decodeURI(url);
  }
}

http.createServer( function (req, res) {
  var index = "./stream"
  ,   fileName
  ,   interval
  ;

  if (req.url === "/")
    fileName = index;
  else fileName = fileNameWithRealExtension( req.url )

  if (fileName === "./stream")
    acceptSubscriber( req, res );
  else if (fileName === "./cmd")
    interpretCommand(req, res);
  else
    serveFile(req, res, fileName);
    
}).listen( port, "::");
console.log("Server listening at 0.0.0.0:" + port);

// ## Helper function(s)
function handleFileError( err, res, checkNoEnt ) {
  // Check file existence by default.
  if (checkNoEnt === undefined)
    checkNoEnt = true;
  if (checkNoEnt && err.code === 'ENOENT') { // (Error, NO ENTity)
    res.writeHead(404);
    res.end();
    console.log("NOT FOUND: " + err.path);
  } else {
    res.writeHead(500, {"Content-Type": "text/plain"});
    res.write(err + '\n');
    res.end();
  }
};

function isSubdir( parent, child ){
  // https://stackoverflow.com/questions/37521893/determine-if-a-path-is-subdirectory-of-another-in-node-js
  const relative = path.relative(parent, child);
  return !relative.startsWith('..') && !path.isAbsolute(relative);
};


// # Serve request handlers ----------------------------------------------------
async function acceptSubscriber( req, res) {
  if ( req.headers.accept === "text/event-stream"
       || req.headers.accept === "*/*" // Needed for a hack elsewhere...
     ) {
    res.writeHead( 200, {
      'content-type': "text/event-stream"
      ,'cache-control': "no-cache"
      ,'connection': "keep-alive"
      ,'Access-Control-Allow-Origin': "*"
    });

    // Support the polyfill
    if (req.headers['x-requested-with'] == 'XMLHttpRequest') 
      res.xhr = null;

    if (req.headers['last-event-id']) {
        var id = parseInt(req.headers['last-event-id']);
        console.log("Request last event id: " + id);
      for (const histItem of history) {
        if (histItem.id > id) {
          sendSSE(res, histItem.id, histItem.event, histItem.message);
        }
      }
    } else {
      // resets the ID
      res.write('id\n\n');
    }

    connections.push(res);
    broadcast('connections', connections.length);

    req.on('close', function () {
      removeConnection(res);
    });
  } 
};  

async function interpretCommand( req, res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "sl-cmd, slide, item, x-referer");
  function closeCmd(req) {
      res.write(JSON.stringify(lastMessageId));
      res.end();
  };    
  var closeForMe = true;
  
  switch (req.headers['sl-cmd']) {
  case 'next':
    broadcast('next','');
    break;
  case 'prev':
    broadcast('prev','');
    break;
  case 'goto':
    var slide = req.headers['slide'];
    var item = req.headers['item'];
    broadcast('goto',slide+'\n'+item);
    break;
  case 'black':
    broadcast('black','');
    break;
  case 'reload':
    broadcast('reload','');
    break;
  case 'nej':
    broadcast('nej','');
    saveNEJ( req.headers );
    break;
  case 'd':
    var stanza = '';
    closeForMe = false;
    req.on('end', () => {
      broadcast('d', stanza);
      closeCmd(req);
    });
    req.on('data', (chunk) => {stanza += chunk;});
    break;
  }

  if (closeForMe) {
    closeCmd(req);
  }
  console.log(req.headers['sl-cmd']);
};

let NEJWrite = Promise.resolve();
async function saveNEJ( headers ){
  NEJWrite = NEJWrite.then( async () => {
    // x-referer is for the test script
    if ( !headers['referer'] && !headers['x-referer'] ){
      console.log( "NEJ command with no referer. Don't know which file to modify." )
      return Promise.resolve()
    }
    let fileName = fileNameWithRealExtension(
      (new URL(headers['referer'] || headers['x-referer']).pathname )
    )
    async function backupCopier(){
      return await fsp.copyFile(
        fileName,
        "backup_copies/"
          + path.basename( fileName, path.extname( fileName ) )
          + Math.floor(((new Date).getTime() %3.154E10 / 300000))
          + '.' + path.extname( fileName ),
        fs.constants.COPYFILE_EXCL )
        .catch( async e => {
          if ( e.code == "ENOENT" ){
            console.log( e )
            await fsp.mkdir( "backup_copies" )
            return await backupCopier()
          }
          if ( e.code != "EEXIST" ) throw e
        })
    }
    let copy = backupCopier()
    html = parser.parse( await fsp.readFile( fileName, 'utf-8' ) )
    try {
      html.querySelectorAll(
        ( "section.slides article:nth-child({}) .build > :not(no-build),"
          + "section.slides article:nth-child({}).build > :not(no-build),"
          + "section.slides article:nth-child({}) .build-me:not(no-build)"
        ).replaceAll( "{}", +headers["slide"] + 1 ))[+headers["item"] - 1]
        .classList.toggle( "nej" )
    } catch { /* der er nok noget galt med din html */ }
    await copy
    return fsp.writeFile( fileName, html.outerHTML, 'utf-8' )
  })
}

async function serveFile( req, res, fileName, searchList ) {
  let proposedPath = path.join( (searchList !== undefined ? searchList[0] : ""), fileName )
  if ( ![ 'GET', 'HEAD' ].includes( req.method ) ){
    res.writeHead( 403 )        // forbidden
    res.end()
    console.log( req.method + " request from " + req.socket.remoteAddress + " DENIED!" )
    return
  }
  [ ['Access-Control-Allow-Origin', "*"]
  , ['Access-Control-Allow-Headers', "*"]
  , ['Accept-Ranges', "bytes"]
  ].forEach( e => res.setHeader.apply( res, e ) )
  fs.stat( proposedPath, (err, stat) => {
    if (err) {
      if (path.extname(proposedPath) === ".vtt") {
        return tryOtherSubFormats( req, res, proposedPath );
      } else {
        if ( searchList === undefined ) {
          searchList = ["node_modules/@fysikrevy/av-main/"].concat(
            process.env.NODE_MODULES_PATH?.split(";") || []
          )
        } else {
          searchList = searchList.slice( 1 )
        }
        if ( searchList.length == 0 ) {
          err.path = fileName
          return handleFileError( err, res )
        }
        return serveFile( req, res, fileName, searchList )
      }
    } else {

      var contentType = contentTypesByExtension[path.extname(proposedPath)] || "text/plain"
      ,   total = stat.size
      ,   mtime = new Date( stat.mtimeMs )
      ,   headers = {}
      ;
      if ( contentType ) res.setHeader( 'Content-Type', contentType );
      [ [ 'Last-Modified', mtime.toUTCString() ]
      , [ 'content-length', total ]
      ].forEach( e => res.setHeader.apply( res, e ) )

      // Caching headers
      res.setHeader('Cache-Control'
                   ,"public, " + (( contentType.startsWith( "font" ) )
                                  ? "immutable, max-age=31536000" // fonts won't change
                                  : "must-revalidate, max-age=0" // everything else might
                                 )
                   )

      let file = null
      let echo = ""
      
      if (req.headers['range']) {
        var range = req.headers.range
	     ,   parts = range.replace(/bytes=/, "").split("-")
	     ,   partialstart = parts[0]
	     ,   partialend = parts[1]
	     ,   start = parseInt(partialstart, 10)
	     ,   end = partialend ? parseInt(partialend, 10) : total-1
	     ,   chunksize = (end-start)+1
        ;
	     echo += (fileName + ': RANGE: ' + start + ' - ' + end
                 + ' = ' + chunksize + '  TO: ' + req.socket.remoteAddress);
	     file = [ fs.createReadStream, proposedPath, {start: start, end: end} ];
        [ [ 'Content-Range', 'bytes ' + start + '-' + end + '/' + total ]
          , [ 'Content-Length', chunksize ]
        ].forEach( e => res.setHeader.apply( res, e ) )
	     res.statusCode = 206;
      } else {
	     echo += (fileName + ': (' + total + ')  TO: '
                 + req.socket.remoteAddress);
        file = [ fs.createReadStream, proposedPath ]
      }
      if ( req.method == 'HEAD' ){
        echo += ", sending no body for HEAD request"
        file = [ () => Readable.from( async function* nothing(){return}() ) ]
      }

      console.log( echo, res.statusCode )
      file[0].apply( null, file.slice(1) )
        .pipe( res )
        .on( 'end', res.end )
        .on( 'error', (err) => handFileError( err, res ) )
    }
  });
};

function tryOtherSubFormats( req, res, fileName) {
  fs.readFile
  (path.dirname(fileName) + path.sep
   + path.basename(fileName, ".vtt") + ".srt",
   function(err, srtFile) {
     if (!err) {                // Found an .srt file
       srt2vtt(srtFile, function(s2verr, vttData) {
         if (!s2verr) {
           res.writeHead(200, { 'Content-Type':
                                  contentTypesByExtension['.vtt']
                                   + "; charset=utf-8" });
           res.write(vttData, "utf8");
           res.end();
           console.log(fileName + " (converted from .srt)");

         } else                 // .srt file didn't work
           handleFileError(s2verr, res);
       });
     } else if (err.code === "ENOENT") { // No .srt file
         var assFile = fs.createReadStream(
           path.dirname(fileName) + path.sep
             + path.basename(fileName, ".vtt") + ".ass")
             .on("error", (a2verr) => {
               // res.removeHeader("Content-Type");
               a2verr.path = a2verr.path.replace(".ass", ".vtt");
               handleFileError(a2verr, res);
             })
             .on("end", () => {
               console.log(fileName + " (converted from .ass)  TO: "
                           + req.socket.remoteAddress);
               res.end();
             })
             .on("open", () => {
               res.statusCode = 200;
               res.setHeader("Content-Type", contentTypesByExtension['.vtt']
                             + "; charset=utf-8");
               assFile.pipe(ass2vtt()).pipe(res);
             });
     } else
       handleFileError(err, res);
   });
};
           

// # SSE functions -------------------------------------------------------------
function removeConnection(res) {
  var i = connections.indexOf(res);
  if (i !== -1) {
    connections.splice(i, 1);
  }
  broadcast('connections', connections.length);
  console.log('removed connection');
}

function broadcast(event, message) {
  if (!isNaN(message))  message = JSON.stringify(message);
  ++lastMessageId;
  history.push({
    id: lastMessageId,
    event: event,
    message: message
  });

  console.log('broadcast to %d connections', connections.length);

  connections.forEach(function (res) {
    sendSSE(res, lastMessageId, event, message);
  });
}

function sendSSE(res, id, event, message) {
  var data = '';
  if (event) {
    data += 'event: ' + event + '\n';
  }

  // blank id resets the id counter
  if (id) {
    data += 'id: ' + id + '\n';
  } else {
    data += 'id\n';
  }

  if (message) {
    data += 'data: ' + message.split('\n').join('\ndata:') + '\n';
  }
  data += '\n'; // final part of message

  res.write(data);

  if (res.hasOwnProperty('xhr')) {
    clearTimeout(res.xhr);
    res.xhr = setTimeout(function () {
      res.end();
      removeConnection(res);
    }, 250);
  }
  console.log(message);
}
